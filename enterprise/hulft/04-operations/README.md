# 04 · 集信/配信实战（送受信 + 重试机制）

> **目标**：掌握生产环境中的 HULFT 传输操作
> **前置**：[03 · 字符编码处理](../03-encoding/)
> **适用**：日本 SIer/银行 IT 岗位面试准备
> **时长**：约 75 分钟
> **费用**：使用 Lesson 02 部署的环境；完成后请参考 [02 · 安装配置](../02-installation/) 清理资源

---

> **版本说明**：
> - 本教程基于 **HULFT8**
> - **HULFT10** 已于 2024年12月发布
> - HULFT8 标准支持结束：2030年6月
> - 新项目建议评估 HULFT10

## 将完成的内容

1. 掌握 flowsend vs sendfile 的使用场景
2. 配置重试机制和重复防止
3. 设计転送グループ（Transfer Group）批次流程
4. 理解日本银行典型传输场景

---

## Step 1 — flowsend vs sendfile

### 两种传输方式对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    flowsend vs sendfile                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   flowsend（预定义传输）              sendfile（临时传输）                   │
│   ┌─────────────────────┐            ┌─────────────────────┐               │
│   │                     │            │                     │               │
│   │  使用 hlmdef.tbl    │            │  命令行直接指定     │               │
│   │  中的传输定义       │            │  目标和参数         │               │
│   │                     │            │                     │               │
│   │  • 重试配置预设     │            │  • 快速灵活         │               │
│   │  • 编码转换预设     │            │  • 无需预配置       │               │
│   │  • 审计追踪完整     │            │  • 适合测试         │               │
│   │  • 生产环境标准     │            │  • 有限的控制       │               │
│   │                     │            │                     │               │
│   └─────────────────────┘            └─────────────────────┘               │
│                                                                             │
│   ⭐ 生产环境：必须用 flowsend       🔧 测试环境：可用 sendfile            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 详细对比

| 特性 | flowsend | sendfile |
|------|----------|----------|
| **配置方式** | 预定义在 hlmdef.tbl | 命令行参数 |
| **重试控制** | 精细配置 | 有限 |
| **编码转换** | 预设 | 需手动指定 |
| **审计追踪** | 完整记录 | 基本记录 |
| **传输组支持** | 支持 | 不支持 |
| **适用场景** | 生产批处理 | 测试验证 |
| **银行合规** | 符合（監査対応） | 不符合 |

### flowsend 使用示例

> **命令说明**：本教程使用 `hulcmd` 命令。官方文档中对应命令为 `utlsend`。
> 不同版本/平台的命令名称可能略有差异，请参考 `hulcmd -help` 或官方手册。

> **注意**：以下为**概念示例**（伪代码格式），展示配置逻辑结构。
> 实际 HULFT 配置通过 **HULFT Manager GUI** 或平台特定配置文件完成，语法与此不同。

```bash
# 1. 首先在 hlmdef.tbl 中定义传输
# 传输定义示例（简化）
TRANSFER_ID: DAILY_REPORT_001
  SOURCE_FILE: /data/reports/daily_*.csv
  TARGET_NODE: NODE_B
  TARGET_FILE: /data/incoming/daily_report.csv
  SOURCE_CODE: SJIS
  TARGET_CODE: UTF-8
  RETRY_COUNT: 3
  RETRY_INTERVAL: 60

# 2. 使用 flowsend 执行
/opt/hulft8/bin/hulcmd -flowsend DAILY_REPORT_001

# 检查返回码
echo "RC=$?"
```

### sendfile 使用示例

```bash
# 直接在命令行指定所有参数（测试用）
/opt/hulft8/bin/hulcmd -sendfile \
  -node NODE_B \
  -file /tmp/test.txt \
  -dest /tmp/received.txt

# 适合快速验证连通性
```

> 💡 **面试要点 #1**
>
> **问题**：「銀行のバッチ処理フローにおいて、sendfileではなくflowsendを選択するのはどのような場合ですか？」
>
> （中文参考：在银行批处理流程中，什么情况下选择 flowsend 而不是 sendfile？）
>
> **期望回答**：
> - **flowsend 用于生产**：预定义配置、重试设置、审计追踪
> - **sendfile 用于测试**：快速验证、无需预配置
> - 银行要求 flowsend 以满足監査対応（审计合规）
> - 所有生产传输必须有可追溯的定义

---

## Step 2 — 重试机制详解

### 重试配置参数

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         HULFT 重试机制                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   传输开始                                                                   │
│      │                                                                      │
│      ▼                                                                      │
│   ┌──────────────────┐                                                      │
│   │  写入本地 Spool  │                                                      │
│   └────────┬─────────┘                                                      │
│            │                                                                │
│            ▼                                                                │
│   ┌──────────────────┐     失败      ┌──────────────────┐                  │
│   │   发送到对端     │ ───────────→  │   等待重试间隔   │                  │
│   └────────┬─────────┘               │  (RETRY_INTERVAL)│                  │
│            │                         └────────┬─────────┘                  │
│            │ 成功                              │                            │
│            ▼                                   │ 重试次数 < RETRY_COUNT     │
│   ┌──────────────────┐                        │                            │
│   │   等待确认 ACK   │               ┌────────┴─────────┐                  │
│   └────────┬─────────┘               │  从断点续传      │                  │
│            │                         │  (RESUME_OFFSET) │                  │
│            ▼                         └──────────────────┘                  │
│   ┌──────────────────┐                                                      │
│   │   传输完成       │     重试次数 >= RETRY_COUNT                          │
│   │   RC=0           │               │                                      │
│   └──────────────────┘               ▼                                      │
│                              ┌──────────────────┐                           │
│                              │   传输失败       │                           │
│                              │   RC=8           │                           │
│                              └──────────────────┘                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 配置示例

```bash
# 在传输定义中设置重试参数
TRANSFER_ID: CRITICAL_BATCH
  # 基本设置
  SOURCE_FILE: /data/batch/critical_data.dat
  TARGET_NODE: CORE_SERVER

  # 重试配置
  RETRY_COUNT: 5          # 最多重试 5 次
  RETRY_INTERVAL: 120     # 每次重试间隔 120 秒

  # 超时设置
  SEND_TIMEOUT: 300       # 发送超时 300 秒
  ACK_TIMEOUT: 60         # 确认超时 60 秒
```

### 断点续传原理

```
场景：100MB 文件传输到 60MB 时网络中断

传统 FTP：
  重传整个 100MB

HULFT 断点续传：
  1. Spool 记录已发送偏移量 (60MB)
  2. 重试时从 60MB 位置继续
  3. 只传输剩余 40MB

优势：
  • 节省带宽
  • 缩短恢复时间
  • 适合大文件传输
```

---

## Step 3 — 重复防止机制

### 为什么需要重复防止？

```
问题场景：

   发送方                    接收方
      │                        │
      │ ────── 数据 ─────────→ │  ✓ 数据到达
      │                        │
      │ ←───── ACK ──────────  │  ✗ ACK 丢失！
      │                        │
      │  超时，认为失败        │
      │  重新发送...           │
      │                        │
      │ ────── 数据 ─────────→ │  ⚠️ 重复数据！

如果没有去重机制：
  银行转账重复执行 = 重大事故！
```

### HULFT 去重机制

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      HULFT 重复防止机制                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   管理情報（Management Info）                                                │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                                                                     │   │
│   │   File-ID: DAILY_REPORT_001                                         │   │
│   │   Sequence: 00000147                                                │   │
│   │   Timestamp: 2024-12-08 23:00:05                                    │   │
│   │   Status: DELIVERED                                                 │   │
│   │                                                                     │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   去重流程：                                                                 │
│                                                                             │
│   1. 发送方生成唯一 File-ID + Sequence                                      │
│   2. 接收方记录已处理的 Sequence                                            │
│   3. 重试时，接收方检查 Sequence：                                          │
│      • 新 Sequence → 正常处理                                               │
│      • 已存在 Sequence → 丢弃重复，返回确认                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### WAN 抖动场景

```bash
# 典型 WAN 抖动场景处理流程：

1. 传输进行中...
2. 网络中断 5 分钟
3. HULFT 发送方：
   - 检测超时
   - 等待 RETRY_INTERVAL
   - 从断点重试
4. 网络恢复
5. 重试成功
6. 接收方检查 Sequence：
   - 如果已处理 → 丢弃，返回 ACK
   - 如果未处理 → 正常接收
7. 发送方收到 ACK，传输完成
```

> 💡 **面试要点 #2**
>
> **问题**：「WAN障害後にリトライが発生した場合、重複配信を防ぐ仕組みは何ですか？」
>
> （中文参考：WAN 故障后发生重试时，什么机制可以防止重复传输？）
>
> **期望回答**：
> - 序列号 + File-ID 在管理情報中追踪
> - 接收方检查序列号是否已处理
> - 重复数据被丢弃，但仍返回确认
> - Spool 元数据支持断点续传，不是重新开始

---

## Step 4 — 転送グループ（Transfer Group）

### 什么是転送グループ？

```
転送グループ（Transfer Group）= 有序的传输批次

特点：
• 多个传输的逻辑分组
• 支持顺序依赖（A 完成后才执行 B）
• 支持条件分支（A 失败则跳过 B）
• 支持后处理动作（通知、触发下游）
```

### 转送グループ示例

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    転送グループ：日次決済バッチ                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────┐                                                       │
│   │ STEP 1          │                                                       │
│   │ 接收决算数据    │                                                       │
│   │ (集信 from DMZ) │                                                       │
│   └────────┬────────┘                                                       │
│            │ RC=0                                                           │
│            ▼                                                                │
│   ┌─────────────────┐                                                       │
│   │ STEP 2          │                                                       │
│   │ 编码转换        │                                                       │
│   │ (SJIS → UTF-8)  │                                                       │
│   └────────┬────────┘                                                       │
│            │ RC=0                                                           │
│            ▼                                                                │
│   ┌─────────────────┐        ┌─────────────────┐                           │
│   │ STEP 3          │        │ STEP 3-ERR      │                           │
│   │ 配信到外部伙伴  │───RC≠0─→│ 发送错误通知    │                           │
│   │ (配信 to EXT)   │        │ (Alert)         │                           │
│   └────────┬────────┘        └─────────────────┘                           │
│            │ RC=0                                                           │
│            ▼                                                                │
│   ┌─────────────────┐                                                       │
│   │ STEP 4          │                                                       │
│   │ 发送完成确认    │                                                       │
│   │ (配信 to Core)  │                                                       │
│   └─────────────────┘                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 配置示例

```bash
# 転送グループ定義（简化示例）
TRANSFER_GROUP: DAILY_SETTLEMENT
  DESCRIPTION: "日次決済バッチ"
  SCHEDULE: "23:00"

  STEPS:
    - STEP_ID: 1
      TRANSFER: RECEIVE_SETTLEMENT_DATA
      ON_SUCCESS: STEP_2
      ON_FAILURE: ABORT

    - STEP_ID: 2
      TRANSFER: CONVERT_ENCODING
      ON_SUCCESS: STEP_3
      ON_FAILURE: ABORT

    - STEP_ID: 3
      TRANSFER: SEND_TO_PARTNER
      ON_SUCCESS: STEP_4
      ON_FAILURE: STEP_3_ERR

    - STEP_ID: 3_ERR
      ACTION: NOTIFY
      NOTIFY_TARGET: ops-team@bank.co.jp

    - STEP_ID: 4
      TRANSFER: SEND_CONFIRMATION
      ON_SUCCESS: COMPLETE
      ON_FAILURE: NOTIFY
```

> 💡 **面试要点 #3**
>
> **问题**：「転送グループとは何ですか？銀行での使用例を挙げて説明してください。」
>
> （中文参考：什么是転送グループ（传输组）？请举一个银行使用的例子说明。）
>
> **期望回答**：
> - **転送グループ**：有序批次，支持依赖和条件
> - **银行示例**：日次決済バッチ
>   1. 从核心系统接收决算文件
>   2. 编码转换
>   3. 发送到外部合作伙伴
>   4. 发送完成确认到核心
> - 依赖确保顺序，条件处理失败情况

---

## Step 5 — 日本银行典型场景

### 场景 1：日次バッチ（日结批处理）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         日次バッチ（Daily Batch）                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   时间线：                                                                   │
│   ───────────────────────────────────────────────────────────────────────   │
│   23:00        23:30        00:00        05:00        06:00                 │
│     │            │            │            │            │                   │
│     ▼            ▼            ▼            ▼            ▼                   │
│   ETL完成    HULFT开始    数据确认    报表生成    营业开始前                 │
│              传输         到达        完成        必须完成                   │
│                                                                             │
│   流程：                                                                     │
│   Core System ──→ HULFT ──→ Branch Servers                                  │
│   (决算数据)      (配信)     (分行报表)                                      │
│                                                                             │
│   关键要求：                                                                 │
│   • 23:00 开始，06:00 前必须完成                                            │
│   • JP1 触发 HULFT flowsend                                                 │
│   • 失败需立即通知夜间值班                                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 场景 2：全銀ファイル（银行间清算）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    全銀ファイル連携（Zengin File Transfer）                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   外部银行                   本行                                            │
│   ┌─────────┐              ┌─────────────────────────────────────────┐     │
│   │         │              │                                         │     │
│   │  清算   │   放置文件   │   DMZ        集信        Core           │     │
│   │  系统   │ ──────────→ │  HULFT  ←─────────────  HULFT           │     │
│   │         │              │                          │              │     │
│   └─────────┘              │                          ▼              │     │
│                            │                      勘定系統           │     │
│                            │                    (Core Banking)       │     │
│                            └─────────────────────────────────────────┘     │
│                                                                             │
│   关键点：                                                                   │
│   • 使用集信（Pull）模式                                                    │
│   • Core 主动拉取，DMZ 不开入站                                             │
│   • 定时窗口：15:00, 18:00, 21:00                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 场景 3：カード認証（信用卡授权）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    カード認証ログ連携                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   VISA/Master                 银行                                          │
│   ┌─────────┐              ┌─────────────────────────────────────────┐     │
│   │         │   授权日志   │                                         │     │
│   │  卡组织 │ ──────────→ │   DMZ HULFT  ←── 集信 ──  Core HULFT    │     │
│   │         │   (每小时)   │                              │          │     │
│   └─────────┘              │                              ▼          │     │
│                            │                          风控系统       │     │
│                            │                        (不正検知)       │     │
│                            └─────────────────────────────────────────┘     │
│                                                                             │
│   处理要求：                                                                 │
│   • 每小时批量传输                                                          │
│   • 低延迟（15分钟内处理完成）                                              │
│   • 数据不能丢失或重复                                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Step 6 — 实践：模拟重试场景

### 准备测试环境

```bash
# Node A: 创建测试文件
dd if=/dev/urandom of=/tmp/large_test.bin bs=1M count=50
# 创建 50MB 测试文件

# 确认文件大小
ls -lh /tmp/large_test.bin
```

### 模拟网络中断（使用 iptables）

> ⚠️ **重要**：以下 iptables 命令需要 root 权限。在生产环境中**切勿执行**此类测试，
> 仅在隔离的 Lab 环境中进行。执行前确保了解如何恢复网络连接。

> **前提**：需要先在 HULFT 中定义 `LARGE_FILE_TEST` 传输配置，或使用您自己的传输 ID。
> 如果尚未配置，可以使用 `sendfile` 命令进行类似测试。

```bash
# 在 Node A 上执行（需要 root 权限）

# 1. 开始传输（使用您定义的传输 ID 或替换为 sendfile 命令）
/opt/hulft8/bin/hulcmd -flowsend LARGE_FILE_TEST &

# 2. 等待几秒后中断网络（模拟 WAN 抖动）
sleep 5
sudo iptables -A OUTPUT -p tcp --dport 8594 -j DROP
sudo iptables -A OUTPUT -p tcp --dport 8500 -j DROP

# 3. 观察日志（另一个终端）
tail -f /opt/hulft8/log/hulft.log

# 4. 等待 30 秒后恢复网络
sleep 30
sudo iptables -D OUTPUT -p tcp --dport 8594 -j DROP
sudo iptables -D OUTPUT -p tcp --dport 8500 -j DROP

# 5. 观察重试和续传
```

### 观察结果

```bash
# 检查日志中的重试记录
grep -E "RETRY|RESUME" /opt/hulft8/log/hulft.log

# 期望看到：
# ... RETRY attempt 1 ...
# ... RESUME from offset 20971520 ...  (从 20MB 位置续传)
# ... RC=0 ...  (最终成功)

# 检查文件完整性
md5sum /tmp/large_test.bin           # Node A
md5sum /tmp/received_large.bin       # Node B
# MD5 应该相同
```

---

## Step 7 — 监控与告警

### 关键监控指标

| 指标 | 正常范围 | 告警阈值 |
|------|----------|----------|
| 传输成功率 | > 99.9% | < 99% |
| 平均传输时间 | 基线 ±20% | > 基线 50% |
| 重试次数 | < 0.1/传输 | > 1/传输 |
| Spool 使用率 | < 70% | > 85% |
| 队列积压 | 0 | > 10 |

### HULFT 返回码（RC）参考

| RC | 含义 | 处理建议 |
|----|------|----------|
| **0** | 成功 | 正常完成 |
| **4** | 警告 | 检查日志，可能有非致命问题 |
| **8** | 错误 | 传输失败，需要调查 |
| **12** | 严重错误 | 系统级问题，立即处理 |

> **注意**：实际返回码可能因版本和平台而异，请参考官方文档获取完整列表。

### 日志监控命令

```bash
# 检查最近失败
grep "RC=[^0]" /opt/hulft8/log/hulft.log | tail -20

# 检查重试情况
grep "RETRY" /opt/hulft8/log/hulft.log | wc -l

# 检查队列状态
/opt/hulft8/bin/hulstat -queue

# 检查 Spool 磁盘使用
df -h /opt/hulft8/spool
```

### 告警设置建议

```bash
# 示例：简单监控脚本
#!/bin/bash
# hulft_monitor.sh

# 检查最近 1 小时失败
FAILURES=$(grep "RC=[^0]" /opt/hulft8/log/hulft.log | \
  awk -v d="$(date -d '1 hour ago' '+%Y-%m-%d %H')" '$0 ~ d' | wc -l)

if [ "$FAILURES" -gt 5 ]; then
  echo "ALERT: $FAILURES HULFT failures in last hour" | \
    mail -s "HULFT Alert" ops-team@example.com
fi

# 检查 Spool 使用率
SPOOL_USAGE=$(df /opt/hulft8/spool | tail -1 | awk '{print $5}' | tr -d '%')

if [ "$SPOOL_USAGE" -gt 85 ]; then
  echo "ALERT: Spool usage at $SPOOL_USAGE%" | \
    mail -s "HULFT Spool Alert" ops-team@example.com
fi
```

---

## 实践练习

### 练习 1：设计転送グループ

**场景**：设计一个月末报表批处理流程

```
要求：
1. 从 3 个分行服务器收集报表
2. 合并到中央服务器
3. 生成汇总报表
4. 发送给管理层
5. 任何一步失败需要通知
```

<details>
<summary>点击查看参考设计</summary>

```yaml
TRANSFER_GROUP: MONTHLY_REPORT
  DESCRIPTION: "月末報表処理"

  STEPS:
    # 并行收集（可同时执行）
    - STEP_ID: 1A
      TRANSFER: COLLECT_BRANCH_A
      PARALLEL_GROUP: COLLECT
      ON_FAILURE: NOTIFY_OPS

    - STEP_ID: 1B
      TRANSFER: COLLECT_BRANCH_B
      PARALLEL_GROUP: COLLECT
      ON_FAILURE: NOTIFY_OPS

    - STEP_ID: 1C
      TRANSFER: COLLECT_BRANCH_C
      PARALLEL_GROUP: COLLECT
      ON_FAILURE: NOTIFY_OPS

    # 等待所有收集完成后合并
    - STEP_ID: 2
      WAIT_FOR: [1A, 1B, 1C]
      ACTION: MERGE_REPORTS
      ON_SUCCESS: STEP_3
      ON_FAILURE: NOTIFY_OPS

    # 生成汇总
    - STEP_ID: 3
      ACTION: GENERATE_SUMMARY
      ON_SUCCESS: STEP_4
      ON_FAILURE: NOTIFY_OPS

    # 发送给管理层
    - STEP_ID: 4
      TRANSFER: SEND_TO_MANAGEMENT
      ON_SUCCESS: COMPLETE
      ON_FAILURE: NOTIFY_OPS

    - STEP_ID: NOTIFY_OPS
      ACTION: NOTIFY
      TARGET: ops-team@bank.co.jp
```

</details>

### 练习 2：计算重试时间

**问题**：如果配置 RETRY_COUNT=5, RETRY_INTERVAL=120，从首次失败到最终放弃最长需要多久？

<details>
<summary>点击查看答案</summary>

```
计算：
首次尝试: 0 秒
失败后等待: 120 秒
第 1 次重试
失败后等待: 120 秒
第 2 次重试
失败后等待: 120 秒
第 3 次重试
失败后等待: 120 秒
第 4 次重试
失败后等待: 120 秒
第 5 次重试（最后）
失败 → 放弃

总等待时间: 5 × 120 = 600 秒 = 10 分钟

注意：这不包括每次传输尝试本身的时间
如果每次尝试超时 60 秒，总时间可能是：
10 分钟 + 6 × 60 秒 = 16 分钟
```

</details>

---

## 常见错误

| 错误 | 后果 | 预防 |
|------|------|------|
| 用 sendfile 跑生产 | 无审计追踪，无重试配置 | 生产必须用 flowsend |
| 忽略 RC=4 警告 | 批处理继续但数据不完整 | 严格检查所有 RC |
| 不监控 Spool 增长 | 重试风暴填满磁盘 | 监控 Spool 使用率 |
| 重试间隔太短 | 触发防火墙会话超时 | 根据网络环境调整 |

---

## 小结

| 主题 | 要点 |
|------|------|
| flowsend vs sendfile | 生产用 flowsend，测试用 sendfile |
| 重试机制 | 断点续传 + 可配置次数和间隔 |
| 重复防止 | Sequence + File-ID 去重 |
| 転送グループ | 有序批次，支持依赖和条件 |
| 银行场景 | 日次バッチ、全銀連携、カード認証 |

---

## 下一步

完成本课后，请继续：

- **[05 · 作业连携与错误处理（JP1 联动 + 日志分析）](../05-job-integration/)** — 与 JP1 作业调度器集成

---

## 系列导航 / Series Nav

| 课程 | 主题 |
|------|------|
| 00 · 概念与架构 | Store-and-Forward, 术语 |
| 01 · 网络与安全 | 端口、防火墙、服务账户 |
| 02 · 安装配置 | HULFT8 双节点 Lab |
| 03 · 字符编码 | SJIS↔UTF-8, EBCDIC |
| **04 · 集信/配信实战** | ← 当前课程 |
| 05 · 作业联动 | JP1 集成、日志分析 |
| 06 · 云迁移 | HULFT Square, AWS VPC |
