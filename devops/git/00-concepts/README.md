# 00 · 概念导入：Git 的设计哲学

> **目标**：理解 Git 为什么这样设计，建立正确的心智模型
> **时间**：15 分钟阅读
> **费用**：无（纯概念）
> **动手**：本课为概念课，无需环境配置，阅读即可

---

## 版本控制解决什么问题？

在没有版本控制的世界里，你可能见过这样的文件夹：

```
project/
├── main.py
├── main_v1.py
├── main_v2.py
├── main_v2_final.py
├── main_v2_final_REAL.py
├── main_v2_final_REAL_最终版.py
└── main_v2_final_REAL_最终版_老板改过.py
```

这不是段子，这是无数团队的真实写照。

**核心痛点**：

| 问题 | 后果 |
|------|------|
| 谁改了什么？ | 出问题无法追溯 |
| 这行代码为什么这样写？ | 上下文丢失 |
| 能恢复到上周的版本吗？ | 要么没备份，要么找不到 |
| 两个人同时改了同一个文件？ | 互相覆盖，工作白费 |

**版本控制系统（VCS）** 就是为了解决这些问题而生的。

---

## Git 的诞生

2005 年，Linux 内核开发遇到了危机。

Linux 内核是世界上最大的开源项目之一，有数千名开发者分布在全球各地。当时他们使用的版本控制工具 BitKeeper 突然不再免费提供给开源社区。

**Linus Torvalds**（Linux 创始人）决定自己写一个。他的设计目标很明确：

- **极快** — 处理像 Linux 内核这样的大型项目
- **完全分布式** — 没有中央服务器的单点故障
- **支持非线性开发** — 数千个并行分支
- **能处理大规模协作** — 成百上千的贡献者
- **数据完整性** — 任何损坏都能被检测到

两周后，Git 诞生了。

今天，Git 已经成为版本控制的事实标准。GitHub、GitLab、Bitbucket 都基于 Git，几乎所有现代软件开发都离不开它。

---

## 分布式 vs 集中式

Git 之前的版本控制系统（如 SVN、CVS）是 **集中式** 的：

![Centralized vs Distributed VCS](images/centralized-vs-distributed.png)

<details>
<summary>View ASCII source</summary>

```
                集中式版本控制 (SVN)                    分布式版本控制 (Git)
                Centralized VCS                        Distributed VCS

                   ┌─────────┐                         ┌─────────┐
                   │ Central │                         │ Remote  │
                   │ Server  │                         │  Repo   │
                   │ (唯一)   │                         │ (可选)   │
                   └────┬────┘                         └────┬────┘
                        │                                   │
          ┌─────────────┼─────────────┐       ┌─────────────┼─────────────┐
          │             │             │       │             │             │
          ▼             ▼             ▼       ▼             ▼             ▼
     ┌─────────┐   ┌─────────┐   ┌─────────┐  ┌─────────┐   ┌─────────┐   ┌─────────┐
     │  Dev A  │   │  Dev B  │   │  Dev C  │  │  Dev A  │   │  Dev B  │   │  Dev C  │
     │ 工作副本 │   │ 工作副本 │   │ 工作副本 │  │ 完整仓库 │   │ 完整仓库 │   │ 完整仓库 │
     │ (无历史) │   │ (无历史) │   │ (无历史) │  │ (全历史) │   │ (全历史) │   │ (全历史) │
     └─────────┘   └─────────┘   └─────────┘  └─────────┘   └─────────┘   └─────────┘

     服务器挂了？所有人停工！               服务器挂了？本地继续工作！
     网络断了？无法提交！                   网络断了？离线提交，之后同步！
```

</details>

**集中式（SVN）**：
- 所有历史存储在中央服务器
- 开发者只有工作副本，没有完整历史
- 依赖网络连接
- 服务器故障 = 全员停工

**分布式（Git）**：
- 每个开发者都有 **完整的仓库**，包含全部历史
- 可以离线工作，之后再同步
- 没有单点故障
- 速度极快（大部分操作都是本地的）

**关键理解**：在 Git 中，"远程仓库"只是另一个仓库的地址，不是"中央权威"。GitHub 上的仓库并不比你本地的仓库更"真实"，它们只是同步点。

---

## 快照，不是差异

这是 Git 最重要的设计理念之一，也是很多人最初的困惑点。

传统版本控制系统存储的是 **差异（Delta）**：

```
Version 1: 完整文件
Version 2: Version 1 + 差异
Version 3: Version 2 + 差异
...
```

Git 存储的是 **快照（Snapshot）**：

![Snapshots vs Deltas](images/snapshots-vs-deltas.png)

<details>
<summary>View ASCII source</summary>

```
              差异存储 (Delta-based)                   快照存储 (Snapshot-based)

Version 1    ┌────────────────────┐                  ┌────────────────────┐
             │     File A v1      │                  │     File A v1      │
             │     File B v1      │                  │     File B v1      │
             │     File C v1      │                  │     File C v1      │
             └────────────────────┘                  └────────────────────┘
                      │                                       │
Version 2    ┌────────┴────────┐                     ┌────────┴────────┐
             │  Δ A  (A的变化)   │                    │     File A v2      │
             │  (B, C 无变化)   │                     │  → File B v1 (链接) │
             └─────────────────┘                     │  → File C v1 (链接) │
                      │                              └────────────────────┘
Version 3    ┌────────┴────────┐                              │
             │  Δ B  (B的变化)   │                    ┌────────┴────────┐
             │  (A, C 无变化)   │                     │  → File A v2 (链接) │
             └─────────────────┘                     │     File B v2      │
                                                     │  → File C v1 (链接) │
                                                     └────────────────────┘

要得到 Version 3？                                   要得到 Version 3？
需要：v1 + Δ(v2) + Δ(v3)                              直接读取快照！
```

</details>

**差异存储的问题**：
- 要获取某个版本，必须从头累加所有差异
- 历史越长，恢复越慢

**Git 快照的优势**：
- 每个版本都是独立的快照
- 切换版本极快
- 但是！没改变的文件只存储指针（不会浪费空间）

这就是为什么 Git 能在毫秒级切换分支，而某些 VCS 需要等待几秒甚至几分钟。

---

## Git 的三个状态

理解 Git，必须理解文件的三个状态：

![Three States of Git](images/three-states.png)

<details>
<summary>View ASCII source</summary>

```
                         Git 的三个状态
                      The Three States of Git

  ┌─────────────────────────────────────────────────────────────────────┐
  │                           你的项目目录                               │
  └─────────────────────────────────────────────────────────────────────┘

  ┌─────────────────┐    git add     ┌─────────────────┐   git commit   ┌─────────────────┐
  │                 │ ─────────────▶ │                 │ ─────────────▶ │                 │
  │  Working        │                │  Staging Area   │                │   Repository    │
  │  Directory      │                │  (Index)        │                │   (.git)        │
  │                 │                │                 │                │                 │
  │  工作区          │                │  暂存区          │                │   仓库           │
  │                 │ ◀───────────── │                 │ ◀───────────── │                 │
  └─────────────────┘   git restore  └─────────────────┘  git restore   └─────────────────┘
                                                          --staged
  ┌─────────────────────────────────────────────────────────────────────┐
  │                                                                     │
  │  · 你编辑文件的地方      · 下次提交的预览         · 永久保存的历史      │
  │  · 可以随意修改          · 可以精选要提交的内容    · 每个提交有唯一 ID   │
  │  · 未追踪 = 不在版本控制中 · 也叫 Index（索引）     · 可以随时回到任何版本 │
  │                                                                     │
  └─────────────────────────────────────────────────────────────────────┘
```

</details>

**三个区域**：

1. **Working Directory（工作区）**
   - 你实际编辑文件的地方
   - 可以随意修改，Git 不会自动记录

2. **Staging Area（暂存区）**
   - 也叫 Index（索引）
   - 下次提交的"预演"
   - 让你可以精选要提交的内容

3. **Repository（仓库）**
   - `.git` 目录
   - 永久保存的历史记录
   - 每个提交都有唯一的 ID

**为什么需要暂存区？**

假设你同时修改了 3 个文件：
- `config.yaml` — 修复了一个 bug
- `README.md` — 更新了文档
- `test.sh` — 正在实验，还没完成

没有暂存区，你要么全部提交，要么一个都不提交。

有了暂存区，你可以：
```bash
git add config.yaml README.md   # 只暂存前两个
git commit -m "Fix config bug and update docs"
# test.sh 还在工作区，继续改
```

这就是 **精确控制提交内容** 的能力。

---

## SHA-1：Git 的指纹系统

Git 中的每个对象（提交、文件、目录）都有一个唯一的 ID，这个 ID 是用 **SHA-1 哈希算法** 计算的。

```
commit 3a7b9c2e4f1d8a5b6c7d8e9f0a1b2c3d4e5f6a7b

这串 40 位的十六进制数就是这个提交的"指纹"
```

**SHA-1 的特点**：

1. **确定性** — 相同的内容永远产生相同的哈希
2. **唯一性** — 不同的内容（几乎）不可能产生相同的哈希
3. **不可逆** — 无法从哈希反推出原始内容

**这意味着什么？**

```
如果两个提交的 SHA-1 相同，它们的内容一定完全相同。
如果文件被损坏（哪怕一个字节），SHA-1 就会变化。
```

Git 用这个机制保证 **数据完整性**：
- 传输过程中数据损坏？检测到！
- 恶意篡改历史？检测到！
- 存储故障导致文件损坏？检测到！

你经常看到的短 ID（如 `3a7b9c2`）只是完整 SHA-1 的前几位，通常足够唯一。

---

## Git 的心智模型

把这些概念组合起来，形成一个完整的心智模型：

![Git Mental Model](images/git-mental-model.png)

<details>
<summary>View ASCII source</summary>

```
                           Git 心智模型
                        Git Mental Model

    ┌─────────────────────────────────────────────────────────────────┐
    │                         你的电脑                                 │
    │  ┌──────────────────────────────────────────────────────────┐   │
    │  │                     项目目录                              │   │
    │  │  ┌────────────┐  ┌────────────┐  ┌────────────────────┐  │   │
    │  │  │ Working    │  │ Staging    │  │ .git/ (Repository)  │  │   │
    │  │  │ Directory  │  │ Area       │  │                     │  │   │
    │  │  │            │  │            │  │  ┌───────────────┐  │  │   │
    │  │  │  main.tf   │──▶ (预览)     ──▶│  │ Commit C (HEAD)│  │  │   │
    │  │  │  vars.tf   │  │            │  │  │     ↓         │  │  │   │
    │  │  │            │  │            │  │  │ Commit B      │  │  │   │
    │  │  │            │  │            │  │  │     ↓         │  │  │   │
    │  │  │            │  │            │  │  │ Commit A      │  │  │   │
    │  │  │            │  │            │  │  └───────────────┘  │  │   │
    │  │  └────────────┘  └────────────┘  └─────────┬───────────┘  │   │
    │  └────────────────────────────────────────────┼──────────────┘   │
    └───────────────────────────────────────────────┼──────────────────┘
                                                    │
                                          git push / pull
                                                    │
                                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                      远程仓库 (GitHub)                           │
    │                                                                 │
    │  ┌───────────────┐   ┌───────────────┐   ┌───────────────┐     │
    │  │ Commit C      │   │ Commit B      │   │ Commit A      │     │
    │  │ (3a7b9c2)     │ ← │ (8f2d4e1)     │ ← │ (1c5a8b3)     │     │
    │  └───────────────┘   └───────────────┘   └───────────────┘     │
    │                                                                 │
    │  每个提交都有唯一的 SHA-1 ID，内容就是快照                         │
    └─────────────────────────────────────────────────────────────────┘
```

</details>

**关键要点**：

1. **本地优先** — 大部分操作都在本地完成，不需要网络
2. **快照链** — 提交形成一条链，每个指向前一个
3. **SHA-1 ID** — 每个提交都有唯一标识，保证完整性
4. **远程同步** — GitHub 只是另一个仓库，用于协作和备份

---

## 你已经准备好了

理解了这些概念，你就有了正确的心智模型。接下来的课程会把这些概念变成实际操作：

| 课程 | 主题 | 对应概念 |
|------|------|----------|
| 01 | 第一个提交 | 三个状态、add、commit |
| 02 | 远程仓库 | 分布式、push、pull |
| 03 | 分支 | 快照链、指针 |
| 04 | 冲突解决 | 合并、diff |
| 05 | Pull Request | 协作流程 |
| 06 | 日本 IT 应用 | 实战场景 |

**下一步**：

> [01 · 第一个提交：本地仓库](../01-first-commit/)

---

## 延伸阅读

- [Pro Git Book（官方免费电子书）](https://git-scm.com/book/zh/v2)
- [Git 官方文档](https://git-scm.com/doc)
- [GitHub Skills（交互式学习）](https://skills.github.com/)

---

## 系列导航

[Home](../) | [01 · 第一个提交 →](../01-first-commit/)
