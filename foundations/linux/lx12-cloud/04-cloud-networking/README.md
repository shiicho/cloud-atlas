# 04 - 云网络：Linux 视角（Cloud Networking: Linux Perspective）

> **目标**：从 Linux 内部理解云网络，掌握"ss 正常但连不上"的排查方法  
> **前置**：[01 - 云中 Linux 有何不同](../01-cloud-context/)、[LX06 网络管理](../../network/)（ip、ss、nftables 基础）  
> **时间**：2.5 小时  
> **实战场景**：诊断 MTU 导致的"连接建立但无数据"故障  

---

## 将学到的内容

1. 从 Linux 视角理解 VPC 网络概念（子网、ENI、私有/公有 IP）
2. 理解安全组与 nftables 的关系——为什么 ss 显示 LISTEN 但连不上
3. 调试"Unreachable Endpoint"场景（MTU/PMTUD 问题）
4. 处理多 ENI 场景的路由问题
5. 理解云环境的 DNS 配置

---

## 先跑起来！（10 分钟）

> 在学习云网络理论之前，先用 Linux 命令探索你的云实例网络环境。  

在任意 EC2 实例上运行以下命令：

### 探索网络接口

```bash
# 查看网络接口（你会发现它和物理服务器不一样）
ip addr show

# 注意 MTU 值！
ip link show eth0 | grep mtu
```

```
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 9001 qdisc mq state UP
    link/ether 0a:1b:2c:3d:4e:5f brd ff:ff:ff:ff:ff:ff
    inet 10.0.1.52/24 brd 10.0.1.255 scope global dynamic eth0
```

**发现 1**：MTU 是 9001，而非标准以太网的 1500——这是 AWS 的 **Jumbo Frames**。

### 探索路由表

```bash
# 查看路由
ip route

# 查看默认网关
ip route | grep default
```

```
default via 10.0.1.1 dev eth0
10.0.1.0/24 dev eth0 proto kernel scope link src 10.0.1.52
169.254.169.254 dev eth0  # 元数据服务路由
```

**发现 2**：有一条专门到 `169.254.169.254`（元数据服务）的路由。

### 探索 DNS 配置

```bash
# 查看 DNS 配置
cat /etc/resolv.conf

# 测试 DNS 解析
dig +short ec2.amazonaws.com
```

```
; generated by /usr/sbin/dhclient-script
search ap-northeast-1.compute.internal
nameserver 10.0.0.2
```

**发现 3**：DNS 服务器是 VPC 的 `.2` 地址——这是 **AmazonProvidedDNS**。

### 探索监听端口和连接

```bash
# 查看监听端口
ss -tulpn

# 查看已建立的连接
ss -tn state established
```

**你刚刚用标准 Linux 命令探索了云网络。** 接下来让我们理解这些组件的来龙去脉。

---

## Step 1 - VPC 概念映射：Linux 视角（20 分钟）

### 1.1 VPC 网络与传统网络的对比

当你在 Linux 上使用 `ip`、`ss` 命令时，看到的是虚拟化的网络接口。理解 VPC 概念有助于排查云网络问题：

<!-- DIAGRAM: vpc-linux-mapping -->
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        VPC 网络 → Linux 视角映射                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   VPC 概念                        Linux 看到的                               │
│   ─────────                       ────────────                               │
│                                                                             │
│   ┌─────────────┐                 ┌─────────────────────────────────────┐  │
│   │    VPC      │                 │  ip route（路由表）                   │  │
│   │ 10.0.0.0/16 │    ────────►   │  10.0.0.0/16 dev eth0               │  │
│   └─────────────┘                 └─────────────────────────────────────┘  │
│                                                                             │
│   ┌─────────────┐                 ┌─────────────────────────────────────┐  │
│   │   Subnet    │                 │  ip addr（接口地址）                  │  │
│   │ 10.0.1.0/24 │    ────────►   │  inet 10.0.1.52/24 dev eth0         │  │
│   └─────────────┘                 └─────────────────────────────────────┘  │
│                                                                             │
│   ┌─────────────┐                 ┌─────────────────────────────────────┐  │
│   │    ENI      │                 │  eth0（虚拟网卡）                     │  │
│   │ (弹性网络   │    ────────►   │  MAC: 0a:1b:2c:3d:4e:5f             │  │
│   │   接口)     │                 │  私有 IP: 10.0.1.52                  │  │
│   └─────────────┘                 └─────────────────────────────────────┘  │
│                                                                             │
│   ┌─────────────┐                 ┌─────────────────────────────────────┐  │
│   │ Security    │                 │  看不到！                            │  │
│   │   Group     │    ────────►   │  在 Hypervisor 层实施                │  │
│   │ (安全组)    │                 │  ss 显示 LISTEN 但可能被 SG 阻止    │  │
│   └─────────────┘                 └─────────────────────────────────────┘  │
│                                                                             │
│   ┌─────────────┐                 ┌─────────────────────────────────────┐  │
│   │ Route Table │                 │  ip route（默认网关）                │  │
│   │ (VPC路由表) │    ────────►   │  default via 10.0.1.1 dev eth0      │  │
│   └─────────────┘                 └─────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```
<!-- /DIAGRAM -->

### 1.2 ENI：Linux 看到的 eth0

**Elastic Network Interface (ENI)** 是 VPC 中的虚拟网络接口：

```bash
# 查看 ENI 信息
ip link show eth0

# 从元数据服务获取 ENI ID
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/
```

ENI 的关键属性：

| 属性 | 说明 | Linux 查看命令 |
|------|------|----------------|
| MAC 地址 | 在 VPC 内唯一 | `ip link show eth0` |
| 私有 IP | 从子网 CIDR 分配 | `ip addr show eth0` |
| 安全组 | 绑定到 ENI（不是实例） | 无法从 Linux 查看 |
| 源/目标检查 | 默认开启，NAT 实例需关闭 | 无法从 Linux 配置 |

### 1.3 私有 IP vs 公有 IP

```bash
# 查看私有 IP（Linux 直接看到）
ip addr show eth0 | grep inet

# 查看公有 IP（通过元数据服务）
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/public-ipv4
```

**关键理解**：公有 IP 是通过 **NAT** 实现的，Linux 内核看不到它。

```
┌──────────────────────────────────────────────────────────────────────┐
│                    公有 IP 的工作原理                                  │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   互联网                  Internet Gateway              EC2 实例     │
│  ─────────               ─────────────────             ─────────     │
│                                                                      │
│  ┌──────────┐           ┌──────────────┐           ┌──────────┐    │
│  │ 客户端   │──────────►│   IGW NAT    │──────────►│  eth0    │    │
│  │          │           │              │           │          │    │
│  │ 目标：   │           │ 公有 IP →    │           │ 私有 IP  │    │
│  │ 54.1.2.3 │           │ 私有 IP      │           │ 10.0.1.52│    │
│  └──────────┘           └──────────────┘           └──────────┘    │
│                                                                      │
│  Linux 看不到 54.1.2.3，只知道自己的 10.0.1.52                        │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 1.4 弹性 IP（Elastic IP）

弹性 IP 是静态公有 IP，实例 Stop/Start 后保持不变：

```bash
# 通过元数据查看是否有 Elastic IP
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/public-ipv4

# 对比实例私有 IP
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/local-ipv4
```

---

## Step 2 - 安全组 vs OS 防火墙（25 分钟）

### 2.1 双层防护模型

云网络安全采用**双层防护**：安全组（外部）+ OS 防火墙（内部）。

<!-- DIAGRAM: security-layers -->
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          双层网络安全模型                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   入站流量                                                                   │
│   ─────────                                                                 │
│                                                                             │
│   ┌───────────┐                                                             │
│   │  互联网   │                                                             │
│   └─────┬─────┘                                                             │
│         │                                                                   │
│         ▼                                                                   │
│   ┌───────────────────────────────────────────────────────────────────┐    │
│   │  Layer 1: Security Group（安全组）                                 │    │
│   │  ─────────────────────────────────                                │    │
│   │  ● 在 Hypervisor 层实施（EC2 外部）                                │    │
│   │  ● 有状态防火墙（允许出站自动允许响应入站）                        │    │
│   │  ● 只能配置 ALLOW 规则，默认 DENY                                 │    │
│   │  ● Linux 看不到，ss 无法检测                                      │    │
│   │                                                                   │    │
│   │  示例：允许 TCP 80, 443 入站                                       │    │
│   └───────────────────────────────────────────────────────────────────┘    │
│         │                                                                   │
│         ▼                                                                   │
│   ┌───────────────────────────────────────────────────────────────────┐    │
│   │  Layer 2: OS Firewall（nftables/firewalld）                       │    │
│   │  ─────────────────────────────────────                            │    │
│   │  ● 在 Linux 内核实施（EC2 内部）                                  │    │
│   │  ● 有状态防火墙（conntrack）                                      │    │
│   │  ● 可配置 ALLOW 和 DROP/REJECT                                   │    │
│   │  ● ss、iptables -L 可以看到                                       │    │
│   │                                                                   │    │
│   │  示例：nft list ruleset                                           │    │
│   └───────────────────────────────────────────────────────────────────┘    │
│         │                                                                   │
│         ▼                                                                   │
│   ┌───────────┐                                                             │
│   │  应用程序  │                                                             │
│   │  (nginx)  │                                                             │
│   └───────────┘                                                             │
│                                                                             │
│   要点：两层都要允许，流量才能到达应用！                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```
<!-- /DIAGRAM -->

### 2.2 安全组特性

安全组是**有状态防火墙**，工作在 Hypervisor 层：

| 特性 | 说明 |
|------|------|
| **有状态** | 允许入站流量后，响应自动允许出站 |
| **只有 ALLOW** | 不能配置 DENY 规则，默认全部 DENY |
| **绑定到 ENI** | 不是实例级，多 ENI 可有不同安全组 |
| **实时生效** | 修改后立即生效，无需重启 |
| **可引用其他安全组** | 如"允许来自 sg-webserver 的流量" |

### 2.3 为什么 ss 显示 LISTEN 但连不上？

这是云网络最常见的困惑场景：

```bash
# Linux 上查看监听端口
ss -tulpn | grep 80

# 输出：
LISTEN  0  511  0.0.0.0:80  0.0.0.0:*  users:(("nginx",pid=1234,fd=6))

# 但从外部 curl 失败！
# curl http://[EC2公有IP] --connect-timeout 5
# curl: (28) Connection timed out
```

**原因分析**：

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    "ss 正常但连不上" 排查流程                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   症状：ss -tulpn 显示 nginx 监听 80 端口，但外部无法访问                 │
│                                                                         │
│   可能原因：                                                             │
│                                                                         │
│   1. 安全组未开放 ───────────────────────────────────────────────────   │
│      │                                                                  │
│      └─► aws ec2 describe-security-groups --group-ids sg-xxx           │
│          检查是否有 TCP 80 入站规则                                      │
│                                                                         │
│   2. NACL（网络 ACL）阻止 ───────────────────────────────────────────   │
│      │                                                                  │
│      └─► aws ec2 describe-network-acls --filter Name=vpc-id,Values=xxx │
│          检查子网级别的 ACL 规则                                         │
│                                                                         │
│   3. OS 防火墙阻止 ─────────────────────────────────────────────────    │
│      │                                                                  │
│      └─► nft list ruleset | grep 80                                    │
│          或 firewall-cmd --list-all                                    │
│                                                                         │
│   4. 服务只监听 localhost ──────────────────────────────────────────    │
│      │                                                                  │
│      └─► ss -tulpn | grep 80                                           │
│          检查是 127.0.0.1:80 还是 0.0.0.0:80                           │
│                                                                         │
│   5. 没有公有 IP 或路由 ────────────────────────────────────────────    │
│      │                                                                  │
│      └─► 检查实例是否在公有子网，是否有公有 IP                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.4 nftables 基础配置

Amazon Linux 2023 使用 nftables（不是 iptables）：

```bash
# 查看当前规则
sudo nft list ruleset

# 添加规则允许 HTTP（临时）
sudo nft add rule inet filter input tcp dport 80 accept

# 使用 firewalld（更友好的前端）
sudo systemctl status firewalld

# firewalld 常用命令
sudo firewall-cmd --list-all
sudo firewall-cmd --add-service=http --permanent
sudo firewall-cmd --reload
```

### 2.5 双层配置示例

**场景**：部署一个 Web 服务器，需要开放 80 和 443 端口。

**Step 1 - 安全组配置**（AWS 层面）：

```bash
# 查看当前安全组规则
aws ec2 describe-security-groups --group-ids sg-xxxxxxxxx \
  --query 'SecurityGroups[0].IpPermissions'

# 添加 HTTP 入站规则
aws ec2 authorize-security-group-ingress \
  --group-id sg-xxxxxxxxx \
  --protocol tcp \
  --port 80 \
  --cidr 0.0.0.0/0

# 添加 HTTPS 入站规则
aws ec2 authorize-security-group-ingress \
  --group-id sg-xxxxxxxxx \
  --protocol tcp \
  --port 443 \
  --cidr 0.0.0.0/0
```

**Step 2 - OS 防火墙配置**（Linux 层面）：

```bash
# 使用 firewalld
sudo firewall-cmd --add-service=http --permanent
sudo firewall-cmd --add-service=https --permanent
sudo firewall-cmd --reload

# 或使用 nftables 直接配置
sudo nft add rule inet filter input tcp dport { 80, 443 } accept
```

---

## Step 3 - DNS 配置（15 分钟）

### 3.1 VPC DNS 解析器

VPC 提供内置的 DNS 解析器（**AmazonProvidedDNS**），地址是 VPC CIDR 的 `.2` 地址：

```bash
# 查看 DNS 配置
cat /etc/resolv.conf

# 典型输出：
search ap-northeast-1.compute.internal
nameserver 10.0.0.2  # VPC CIDR 10.0.0.0/16 → DNS 是 10.0.0.2
```

### 3.2 DNS 解析特性

| 功能 | 说明 |
|------|------|
| **公有 DNS 解析** | 解析互联网域名 |
| **私有主机名解析** | 解析 VPC 内实例的私有 DNS |
| **私有托管区域** | Route 53 私有托管区，仅 VPC 内可见 |
| **DNS64** | 在 IPv6-only 子网解析 IPv4-only 端点 |

### 3.3 实例私有 DNS 名

```bash
# 查看实例的私有 DNS 名
TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/local-hostname

# 典型输出：
ip-10-0-1-52.ap-northeast-1.compute.internal

# 从另一台实例解析
dig ip-10-0-1-52.ap-northeast-1.compute.internal +short
```

### 3.4 systemd-resolved 集成

新版 Linux（如 Ubuntu 22.04+）使用 systemd-resolved：

```bash
# 查看 resolved 状态
resolvectl status

# 查看当前 DNS 服务器
resolvectl dns

# 如果 /etc/resolv.conf 指向 127.0.0.53
# 说明使用了 systemd-resolved 的 stub resolver
```

**注意**：在某些场景下（如 VPN、多 DNS），systemd-resolved 的行为可能与预期不同。

---

## Step 4 - 多 ENI 场景（15 分钟）

### 4.1 为什么需要多 ENI？

| 场景 | 说明 |
|------|------|
| **网络隔离** | 管理网络 + 业务网络分离 |
| **高可用** | 多 AZ 的 ENI 实现快速故障切换 |
| **安全需求** | 不同 ENI 绑定不同安全组 |
| **多 IP** | 一个实例承载多个服务（不同 IP） |

### 4.2 附加辅助 ENI

```bash
# 创建 ENI
aws ec2 create-network-interface \
  --subnet-id subnet-xxxxxxxx \
  --description "Secondary ENI" \
  --groups sg-xxxxxxxx

# 附加到实例
aws ec2 attach-network-interface \
  --network-interface-id eni-xxxxxxxx \
  --instance-id i-xxxxxxxx \
  --device-index 1

# Linux 上会看到新接口
ip link show
# 输出：eth0, eth1（或 ens5, ens6）
```

### 4.3 Linux 路由问题

**问题**：附加第二个 ENI 后，可能出现路由问题。

<!-- DIAGRAM: multi-eni-routing -->
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       多 ENI 路由问题                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   EC2 实例                                                                   │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                                                                     │  │
│   │   eth0: 10.0.1.10/24                  eth1: 10.0.2.10/24           │  │
│   │   GW: 10.0.1.1                        GW: 10.0.2.1                 │  │
│   │                                                                     │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   问题场景：                                                                 │
│   ─────────                                                                 │
│   1. 客户端请求到达 eth1 (10.0.2.10)                                        │
│   2. 响应从默认路由 (eth0) 发出                                              │
│   3. 源 IP 不匹配，连接失败！                                                │
│                                                                             │
│   ┌──────────┐      请求到 10.0.2.10      ┌──────────┐                     │
│   │  客户端   │ ──────────────────────────► │   eth1   │                     │
│   │          │                             │          │                     │
│   │          │ ◄─────── ✗ 失败 ──────────  │   eth0   │  响应走错路了！      │
│   └──────────┘     响应从 10.0.1.10        └──────────┘                     │
│                                                                             │
│   解决方案：策略路由（Policy Routing）                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```
<!-- /DIAGRAM -->

### 4.4 配置策略路由

```bash
# 创建路由表
echo "100 eth1_table" | sudo tee -a /etc/iproute2/rt_tables

# 添加路由规则
sudo ip route add default via 10.0.2.1 dev eth1 table eth1_table
sudo ip rule add from 10.0.2.10/32 table eth1_table

# 验证
ip rule show
ip route show table eth1_table
```

**持久化配置**（Amazon Linux 2023 / RHEL）：

```bash
# 创建 /etc/sysconfig/network-scripts/route-eth1
default via 10.0.2.1 dev eth1 table eth1_table

# 创建 /etc/sysconfig/network-scripts/rule-eth1
from 10.0.2.10/32 table eth1_table
```

---

## Step 5 - MTU 问题深入（20 分钟）

### 5.1 什么是 MTU？

**MTU (Maximum Transmission Unit)** 是网络接口能传输的最大数据包大小。

| 网络类型 | 典型 MTU |
|----------|----------|
| 传统以太网 | 1500 bytes |
| AWS VPC 内 | 9001 bytes（Jumbo Frames） |
| 跨 VPN/DirectConnect | 取决于路径 |
| 互联网 | 1500 bytes（最常见） |

### 5.2 PMTUD 工作原理

**Path MTU Discovery (PMTUD)** 让发送方发现路径上的最小 MTU：

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        PMTUD 工作原理                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   发送方          路由器（MTU 较小）           接收方                    │
│   MTU=9001        MTU=1500                   MTU=9001                  │
│                                                                         │
│   ┌────────┐                                   ┌────────┐              │
│   │ EC2 A  │ ───── 发送 8000 字节包 ─────────► │ EC2 B  │              │
│   │        │          (DF=1)                   │        │              │
│   └────────┘                                   └────────┘              │
│       │                   │                                            │
│       │                   ▼                                            │
│       │           ┌───────────────┐                                    │
│       │           │ 包太大！      │                                    │
│       │           │ 发送 ICMP     │                                    │
│       │           │ Type 3 Code 4 │                                    │
│       │           │ "需要分片"    │                                    │
│       │           └───────┬───────┘                                    │
│       │                   │                                            │
│       ◄───── ICMP 通知 ───┘                                            │
│       │                                                                 │
│       ▼                                                                 │
│   调整发送大小为 1500                                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.3 当 PMTUD 失败时

**问题场景**：某些防火墙阻止 ICMP，导致 PMTUD 失败。

```
症状：
- TCP 三次握手成功（SYN/SYN-ACK/ACK）
- 小包能传输（如 HTTP 请求头）
- 大数据传输卡住（如下载文件）
- curl 显示 "stalled" 或无限等待
```

这就是 **"Unreachable Endpoint"** 场景的根本原因。

### 5.4 诊断 MTU 问题

```bash
# 测试路径 MTU（使用 ping）
# -M do：设置 DF (Don't Fragment) 标志
# -s：指定数据大小（不含 IP 和 ICMP 头）

# 测试 1500 字节（标准以太网）
ping -M do -s 1472 <目标IP> -c 3
# 1472 + 28 (IP头+ICMP头) = 1500

# 测试 9001 字节（AWS Jumbo Frames）
ping -M do -s 8973 <目标IP> -c 3
# 8973 + 28 = 9001

# 如果收到 "Frag needed" 错误，说明 MTU 不够
```

```bash
# 使用 tracepath 发现路径 MTU
tracepath <目标IP>

# 输出示例：
 1:  10.0.1.1                     0.654ms pmtu 9001
 2:  10.0.2.1                     1.234ms pmtu 1500
 3:  192.168.1.1                  15.678ms reached
     Resume: pmtu 1500
```

### 5.5 解决 MTU 问题

**方法 1：调整接口 MTU**

```bash
# 临时调整
sudo ip link set dev eth0 mtu 1500

# 永久配置（Amazon Linux 2023 / RHEL）
# 编辑 /etc/sysconfig/network-scripts/ifcfg-eth0
MTU=1500

# 或使用 nmcli
nmcli connection modify "System eth0" ethernet.mtu 1500
nmcli connection up "System eth0"
```

**方法 2：调整 TCP MSS**

```bash
# MSS = MTU - IP头(20) - TCP头(20) = MTU - 40
# 使用 iptables/nftables 修改 MSS

# nftables 方式
sudo nft add rule ip filter FORWARD tcp flags syn tcp option maxseg size set 1460

# iptables 方式（兼容）
sudo iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1460
```

---

## Lab 1 - 安全组 vs nftables 实验（25 分钟）

### 实验目标

理解双层防护：安全组允许但 nftables 阻止 = 无法访问。

### Step 1 - 准备环境

```bash
# 启动 nginx
sudo yum install -y nginx
sudo systemctl start nginx
sudo systemctl enable nginx

# 确认 nginx 监听
ss -tulpn | grep 80
```

### Step 2 - 验证安全组配置

```bash
# 确保安全组允许 HTTP（80）入站
aws ec2 describe-security-groups --group-ids sg-xxxxxxxx \
  --query 'SecurityGroups[0].IpPermissions[?FromPort==`80`]'

# 如果没有，添加规则
aws ec2 authorize-security-group-ingress \
  --group-id sg-xxxxxxxx \
  --protocol tcp \
  --port 80 \
  --cidr 0.0.0.0/0
```

### Step 3 - 测试访问（安全组允许）

从外部测试：

```bash
# 从本地机器测试
curl -I http://<EC2公有IP>

# 应该成功，返回 HTTP 200
```

### Step 4 - 添加 nftables DROP 规则

```bash
# 在 EC2 实例上阻止 HTTP
sudo nft add rule inet filter input tcp dport 80 drop

# 验证规则
sudo nft list ruleset | grep 80
```

### Step 5 - 再次测试（安全组允许，nftables 阻止）

```bash
# 从本地机器测试
curl -I http://<EC2公有IP> --connect-timeout 10

# 应该超时！因为 nftables 阻止了
# curl: (28) Connection timed out
```

### Step 6 - 理解结果

```
┌────────────────────────────────────────────────────────────────────┐
│                      实验结果分析                                    │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│   场景 1：安全组 ✓ + nftables ✓                                    │
│   结果：访问成功 ✓                                                  │
│                                                                    │
│   场景 2：安全组 ✓ + nftables ✗                                    │
│   结果：访问失败 ✗（本实验）                                        │
│                                                                    │
│   场景 3：安全组 ✗ + nftables ✓                                    │
│   结果：访问失败 ✗                                                  │
│                                                                    │
│   场景 4：安全组 ✗ + nftables ✗                                    │
│   结果：访问失败 ✗                                                  │
│                                                                    │
│   结论：两层都必须允许，流量才能到达应用                            │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### Step 7 - 清理

```bash
# 删除 nftables 规则
sudo nft flush ruleset

# 或重新加载默认规则
sudo systemctl restart nftables
```

### 检查清单

- [ ] 理解安全组在 Hypervisor 层实施
- [ ] 理解 nftables 在 Linux 内核实施
- [ ] 能配置安全组入站规则
- [ ] 能使用 nft 命令管理防火墙规则
- [ ] 理解为什么"ss 正常但连不上"

---

## Lab 2 - Unreachable Endpoint 场景（30 分钟）

### 场景描述

> SSH 正常，ping 正常，但 curl 到特定 API 端点无限挂起。  
> ss 显示连接 ESTABLISHED，但没有数据传输。  

这是生产环境中最隐蔽的网络问题之一。

### 实验目标

学习诊断 MTU 导致的大包传输失败。

### Step 1 - 模拟问题场景

```bash
# 在实例上人为降低 MTU（模拟 VPN 场景）
sudo ip link set dev eth0 mtu 1400

# 查看当前 MTU
ip link show eth0 | grep mtu
```

### Step 2 - 测试小包传输（成功）

```bash
# 小包能正常传输
curl -I https://www.google.com

# 应该成功
```

### Step 3 - 测试大包传输（可能失败或变慢）

```bash
# 下载较大文件
curl -o /dev/null https://speed.cloudflare.com/__down?bytes=10000000 --connect-timeout 10 -w "Speed: %{speed_download}\n"

# 如果 PMTUD 被阻止，可能会非常慢或卡住
```

### Step 4 - 诊断 MTU 问题

```bash
# 方法 1：使用 ping 测试
ping -M do -s 1372 8.8.8.8 -c 3  # 1372 + 28 = 1400 (当前 MTU)
ping -M do -s 1472 8.8.8.8 -c 3  # 1472 + 28 = 1500 (会失败)

# 方法 2：使用 tracepath
tracepath 8.8.8.8

# 方法 3：查看接口 MTU
ip link show eth0
```

### Step 5 - 解决问题

```bash
# 恢复正常 MTU
sudo ip link set dev eth0 mtu 9001  # AWS VPC 内标准值

# 或设置为保守值
sudo ip link set dev eth0 mtu 1500  # 互联网标准值

# 验证
ip link show eth0 | grep mtu
```

### Step 6 - 验证修复

```bash
# 重新测试大文件下载
curl -o /dev/null https://speed.cloudflare.com/__down?bytes=10000000 -w "Speed: %{speed_download}\n"

# 应该正常速度下载
```

### 检查清单

- [ ] 理解 MTU 和 PMTUD 的概念
- [ ] 能使用 `ping -M do -s` 测试 MTU
- [ ] 能使用 `tracepath` 发现路径 MTU
- [ ] 能调整网络接口 MTU
- [ ] 理解为什么"连接建立但无数据"

---

## Lab 3 - 网络故障排查流程（20 分钟）

### 系统化排查方法论

网络问题排查遵循 **L3 → L4 → L7** 的顺序：

<!-- DIAGRAM: network-troubleshooting-flow -->
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     网络故障排查流程 (L3 → L4 → L7)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  Step 1: L3 网络层 - IP 连通性                                       │  │
│   │  ─────────────────────────────                                      │  │
│   │  ping <目标IP>                                                       │  │
│   │  traceroute <目标IP>                                                 │  │
│   │  ip route get <目标IP>                                               │  │
│   │                                                                      │  │
│   │  检查：                                                              │  │
│   │  ✓ 路由是否正确                                                      │  │
│   │  ✓ ICMP 是否可达                                                     │  │
│   │  ✓ 安全组/NACL 是否允许 ICMP                                         │  │
│   └──────────────────────────────────────────────────┬──────────────────┘  │
│                                                       │                     │
│                                                       ▼                     │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  Step 2: L4 传输层 - TCP/UDP 端口                                    │  │
│   │  ─────────────────────────────────                                  │  │
│   │  ss -tulpn                          # 本地监听端口                   │  │
│   │  nc -zv <目标IP> <端口>              # 端口可达性                    │  │
│   │  telnet <目标IP> <端口>              # 端口可达性（备选）            │  │
│   │                                                                      │  │
│   │  检查：                                                              │  │
│   │  ✓ 服务是否监听正确地址（0.0.0.0 vs 127.0.0.1）                     │  │
│   │  ✓ 安全组是否允许该端口                                             │  │
│   │  ✓ nftables 是否允许                                                │  │
│   └──────────────────────────────────────────────────┬──────────────────┘  │
│                                                       │                     │
│                                                       ▼                     │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  Step 3: L7 应用层 - 协议验证                                        │  │
│   │  ─────────────────────────────                                      │  │
│   │  curl -v http://<目标>               # HTTP 详细输出                 │  │
│   │  curl -v https://<目标>              # HTTPS (含 TLS 握手)          │  │
│   │  openssl s_client -connect <目标>:443  # TLS 证书检查               │  │
│   │                                                                      │  │
│   │  检查：                                                              │  │
│   │  ✓ HTTP 响应码                                                       │  │
│   │  ✓ TLS 证书有效性                                                    │  │
│   │  ✓ DNS 解析是否正确                                                  │  │
│   │  ✓ 响应内容是否正确                                                  │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```
<!-- /DIAGRAM -->

### 排查命令速查表

```bash
# === L3 网络层 ===

# 测试 IP 连通性
ping -c 3 <目标IP>

# 追踪路由
traceroute <目标IP>
# 或
mtr <目标IP>

# 查看路由决策
ip route get <目标IP>

# 查看本地路由表
ip route

# 查看 ARP 缓存
ip neigh

# === L4 传输层 ===

# 查看监听端口
ss -tulpn

# 查看已建立连接
ss -tn state established

# 测试端口可达
nc -zv <目标IP> <端口>

# 查看连接状态
ss -tn state all dst <目标IP>

# === L7 应用层 ===

# HTTP 详细请求
curl -v http://<目标>

# 只获取响应头
curl -I http://<目标>

# 带超时的请求
curl --connect-timeout 5 --max-time 10 http://<目标>

# 测试 HTTPS/TLS
openssl s_client -connect <目标>:443 -servername <域名>

# DNS 解析测试
dig <域名>
dig +short <域名>
nslookup <域名>

# === 综合工具 ===

# 抓包分析
sudo tcpdump -i eth0 host <目标IP> -n

# 持续监控连接
watch -n 1 'ss -tn | grep <目标IP>'
```

### 常见问题速查

| 症状 | 可能原因 | 排查命令 |
|------|----------|----------|
| ping 不通 | SG/NACL 阻止 ICMP | 检查安全组入站规则 |
| 端口连不上 | SG 未开放 | `aws ec2 describe-security-groups` |
| 服务连不上 | 监听 127.0.0.1 | `ss -tulpn` 检查绑定地址 |
| 连上但卡住 | MTU 问题 | `ping -M do -s 1472` |
| 间歇性超时 | DNS 问题 | `dig +trace <域名>` |
| TLS 失败 | 证书问题 | `openssl s_client` |

---

## 跨云视角（Cross-Cloud Sidebar）

虽然本课以 AWS 为例，但网络安全双层防护是所有云平台的通用模式：

| 概念 | AWS | GCP | Azure |
|------|-----|-----|-------|
| 虚拟网络 | VPC | VPC | VNet |
| 外部防火墙 | Security Groups | Firewall Rules | NSG |
| 状态性 | 有状态 | 有状态（标签/网络级） | 有状态 |
| 绑定级别 | ENI（接口级） | Network/Tag | Subnet 或 NIC |
| 子网级规则 | Network ACL | VPC Firewall | NSG (subnet) |
| OS 防火墙 | nftables/iptables | nftables/iptables | Windows Firewall/nftables |

**核心原则相同**：

```
外部规则（云平台层）+ 主机规则（OS 层）= 双层防护
```

**GCP 特点**：
- Firewall Rules 应用于整个网络或特定标签
- 支持更灵活的目标匹配（标签、服务账户）

**Azure 特点**：
- NSG 可以应用于子网或单个 NIC
- 支持应用安全组（ASG）进行分组

---

## 反模式演示（Anti-Patterns Demo）

### 反模式 1：只配安全组，忽略 OS 防火墙

```bash
# 错误思维：
# "安全组开了 80，应该能访问了"

# 实际：某些 AMI 默认启用 firewalld，会阻止流量
sudo firewall-cmd --list-all
# 可能显示：services: ssh dhcpv6-client
# 没有 http！
```

**后果**：
- 生产部署后服务不可访问
- 排查时"ss 显示 LISTEN"但连不上
- 浪费大量时间排查安全组

**修复**：

```bash
# 检查并配置 OS 防火墙
sudo firewall-cmd --add-service=http --permanent
sudo firewall-cmd --add-service=https --permanent
sudo firewall-cmd --reload
```

### 反模式 2：忽视合规要求只用安全组

```bash
# 错误思维：
# "安全组已经是防火墙了，不需要 nftables"

# 实际：很多合规标准（CIS、PCI-DSS）要求主机级防火墙
```

**后果**：
- 安全审计不通过
- 缺乏 Defense in Depth
- 如果安全组配置错误，无第二道防线

**修复**：始终配置双层防护。

### 反模式 3：忽视 MTU 问题

```bash
# 错误思维：
# "能 ping 通就是网络正常"

# 实际：小包（ping）能过，大包（HTTP body）可能失败
```

**后果**：
- 应用间歇性超时
- 文件传输失败
- 数据库连接池耗尽

**修复**：

```bash
# 测试大包
ping -M do -s 1472 <目标IP>

# 如果失败，调整 MTU 或检查路径上的设备
```

---

## 职场小贴士（Japan IT Context）

### ネットワーク障害は運用の日常

在日本 IT 现场，网络故障排查（ネットワーク障害対応）是运维工程师的日常工作。以下是常用术语：

| 日语术语 | 读音 | 含义 | 使用场景 |
|----------|------|------|----------|
| 疎通確認 | そつうかくにん | 连通性确认 | "疎通確認をお願いします" |
| ファイアウォール | - | 防火墙 | セキュリティグループ、nftables |
| ポート開放 | ポートかいほう | 端口开放 | "80番ポートを開放してください" |
| ルーティング | - | 路由 | "ルーティングを確認してください" |
| 名前解決 | なまえかいけつ | DNS 解析 | "名前解決ができません" |
| MTU | - | MTU | "MTU問題の可能性があります" |

### 疎通確認の系统方法

日本企业通常有标准的**疎通確認**（连通性确认）流程：

```
┌─────────────────────────────────────────────────────────────────────────┐
│                 疎通確認チェックリスト（连通性确认检查表）                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. L3 確認（レイヤー3確認）                                              │
│     □ ping による ICMP 疎通確認                                          │
│     □ traceroute による経路確認                                          │
│     □ セキュリティグループの ICMP 許可確認                               │
│                                                                         │
│  2. L4 確認（レイヤー4確認）                                              │
│     □ ss -tulpn でリッスンポート確認                                     │
│     □ nc -zv でポート疎通確認                                            │
│     □ セキュリティグループのポート許可確認                               │
│     □ OS ファイアウォール（nftables）確認                                │
│                                                                         │
│  3. L7 確認（レイヤー7確認）                                              │
│     □ curl -v でHTTP応答確認                                             │
│     □ DNS 名前解決確認                                                   │
│     □ SSL/TLS 証明書確認                                                 │
│                                                                         │
│  4. 結果記録                                                             │
│     □ 確認日時                                                           │
│     □ 確認者                                                             │
│     □ 確認結果（OK/NG）                                                  │
│     □ NG の場合の詳細                                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 障害報告の書き方

网络故障报告需要包含以下要素：

```
【障害報告】
■ 発生日時：2025-01-10 14:30 JST
■ 影響範囲：Web サーバー外部アクセス不可
■ 原因：セキュリティグループに HTTP(80) 許可ルールなし
■ 対応内容：セキュリティグループに TCP/80 インバウンドルール追加
■ 復旧日時：2025-01-10 14:45 JST
■ 再発防止策：
  - インフラ構成変更時のチェックリスト追加
  - セキュリティグループ変更の自動テスト導入
```

---

## 检查清单

完成本课后，你应该能够：

- [ ] 解释 VPC 网络概念与 Linux 命令的对应关系（ENI↔eth0, SG↔看不见）
- [ ] 理解安全组与 nftables 的双层防护模型
- [ ] 诊断"ss 显示 LISTEN 但连不上"的问题
- [ ] 配置安全组入站规则
- [ ] 使用 nftables/firewalld 管理 OS 防火墙
- [ ] 理解 VPC DNS（AmazonProvidedDNS）的工作原理
- [ ] 处理多 ENI 场景的策略路由
- [ ] 诊断 MTU/PMTUD 相关的网络问题
- [ ] 使用 L3→L4→L7 系统化方法排查网络故障
- [ ] 掌握疎通確認（连通性确认）的标准流程

---

## 本课小结

| 概念 | 要点 |
|------|------|
| VPC 映射 | ENI=eth0, 子网=ip addr, 路由表=ip route |
| 安全组 | 外部、有状态、只有 ALLOW、绑定到 ENI |
| nftables | 内部、主机级、可 ALLOW/DROP |
| 双层防护 | 两层都要允许，流量才能到达 |
| DNS | AmazonProvidedDNS (.2 地址)、私有主机名 |
| 多 ENI | 需要策略路由解决非对称路由 |
| MTU | VPC 内 9001、跨 VPN 可能更小、PMTUD 失败会卡住 |

---

## 延伸阅读

- [AWS VPC 用户指南](https://docs.aws.amazon.com/vpc/latest/userguide/) - 官方 VPC 文档
- [Security Groups for Your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html) - 安全组详解
- [nftables Wiki](https://wiki.nftables.org/) - nftables 官方文档
- [Path MTU Discovery](https://en.wikipedia.org/wiki/Path_MTU_Discovery) - PMTUD 原理
- 下一课：[05 - 云存储：EBS 与持久化](../05-cloud-storage/) - 学习 EBS 扩容、救援实例
- 前置课程：[LX06 - 网络管理](../../network/) - Linux 网络基础

---

## 清理资源

本课实验修改了系统配置，记得恢复：

```bash
# 恢复 MTU（如果修改过）
sudo ip link set dev eth0 mtu 9001

# 清理 nftables 规则
sudo nft flush ruleset
# 或重启服务恢复默认
sudo systemctl restart nftables

# 清理安全组测试规则（如需要）
aws ec2 revoke-security-group-ingress \
  --group-id sg-xxxxxxxx \
  --protocol tcp \
  --port 80 \
  --cidr 0.0.0.0/0
```

---

## 系列导航

[← 03 - 元数据服务与 IMDSv2](../03-metadata/) | [系列首页](../) | [05 - 云存储：EBS 与持久化 →](../05-cloud-storage/)
