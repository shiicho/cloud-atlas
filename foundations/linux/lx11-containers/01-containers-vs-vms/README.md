# 01 - 容器 vs 虚拟机：心智模型

> **目标**：建立正确的容器心智模型 —— 容器是「进程 + 约束」，不是轻量 VM  
> **前置**：LX05-SYSTEMD、LX06-NETWORK、LX08-SECURITY 基础知识  
> **时间**：2 小时  
> **环境**：任意 Linux 系统（cgroup v2 enabled）  

---

## 将学到的内容

1. 体验 Linux 容器的核心原语 —— Network Namespace
2. 理解容器和虚拟机的本质区别
3. 建立「Container = Process + Constraints」心智模型
4. 知道何时选择容器、何时选择虚拟机

---

## 先跑起来：10 分钟体验容器原语

> **不讲原理，先动手！** 你马上就会看到容器隔离的魔法。  

### 创建一个隔离的网络环境

打开终端，执行：

```bash
# 创建一个隔离的网络命名空间
sudo unshare --net bash
```

你现在进入了一个「隔离空间」。检查网络接口：

```bash
ip addr
```

输出：

```
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
```

**只有 lo 接口！** 没有 eth0，没有任何外部网络。

尝试 ping 外网：

```bash
ping -c 3 8.8.8.8
```

输出：

```
ping: connect: Network is unreachable
```

**网络不通！** 这个 shell 进程被「隔离」了。

退出隔离空间，回到正常环境：

```bash
exit
```

再次检查网络：

```bash
ip addr | head -20
```

所有网络接口都回来了！

---

**你刚刚做了什么？**

```
┌─────────────────────────────────────────────────────────┐
│                      宿主机                              │
│                                                         │
│   ┌─────────────────┐      ┌─────────────────┐         │
│   │ 普通 Shell      │      │ 隔离 Shell      │         │
│   │                 │      │ (unshare --net) │         │
│   │ eth0: 有网络    │      │ 只有 lo         │         │
│   │ 能 ping 外网    │      │ 无法访问外网    │         │
│   └─────────────────┘      └─────────────────┘         │
│                                                         │
│   共享同一个 Linux 内核                                  │
└─────────────────────────────────────────────────────────┘
```

这就是容器网络隔离的基础原语 —— **Network Namespace**。

一个 `unshare` 命令，你就创建了容器的雏形。没有 Docker，没有复杂工具，只有 Linux 内核能力。

---

## 发生了什么？

### unshare 命令揭秘

`unshare --net bash` 做了什么？

1. **创建新的 Network Namespace** —— 一个独立的网络栈
2. **在新 Namespace 中启动 bash** —— 这个 bash 只能看到新的网络
3. **原来的网络对它「不可见」** —— 这就是「隔离」

**关键洞察**：这个 bash 进程还是宿主机上的普通进程！

验证：在隔离 shell 中运行 `echo $$` 获取 PID，然后在宿主机上 `ps aux | grep <PID>`，你会看到它。

**容器不是虚拟机** —— 它只是一个带约束的进程。

---

## 核心概念：容器 vs 虚拟机

### 虚拟机：完全隔离

<!-- DIAGRAM: vm-architecture -->
```
┌─────────────────────────────────────────────────────────┐
│                    虚拟机架构                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌───────────────┐  ┌───────────────┐  ┌─────────────┐  │
│  │    App A      │  │    App B      │  │   App C     │  │
│  ├───────────────┤  ├───────────────┤  ├─────────────┤  │
│  │  Guest OS     │  │  Guest OS     │  │  Guest OS   │  │
│  │  (Linux)      │  │  (Windows)    │  │  (Linux)    │  │
│  │  独立内核     │  │  独立内核     │  │  独立内核   │  │
│  └───────────────┘  └───────────────┘  └─────────────┘  │
│           │                │                │           │
│           └────────────────┼────────────────┘           │
│                            ▼                            │
│  ┌─────────────────────────────────────────────────────┐│
│  │              Hypervisor (KVM/VMware/Hyper-V)        ││
│  │              硬件虚拟化层                            ││
│  └─────────────────────────────────────────────────────┘│
│                            │                            │
│  ┌─────────────────────────────────────────────────────┐│
│  │              Host OS + Hardware                     ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘

特点：
- 每个 VM 有独立的完整操作系统内核
- Hypervisor 模拟硬件
- 启动时间：分钟级
- 内存：GB 级别
- 隔离：硬件级别（强）
```
<!-- /DIAGRAM -->

### 容器：进程级隔离

<!-- DIAGRAM: container-architecture -->
```
┌─────────────────────────────────────────────────────────┐
│                    容器架构                              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌───────────────┐  ┌───────────────┐  ┌─────────────┐  │
│  │  Container A  │  │  Container B  │  │ Container C │  │
│  │    App A      │  │    App B      │  │   App C     │  │
│  │  (进程)       │  │  (进程)       │  │  (进程)     │  │
│  └───────┬───────┘  └───────┬───────┘  └──────┬──────┘  │
│          │                  │                 │         │
│          │    Namespace     │    cgroups      │         │
│          │    (隔离可见性)  │    (限制资源)   │         │
│          │                  │                 │         │
│          └──────────────────┼─────────────────┘         │
│                             ▼                           │
│  ┌─────────────────────────────────────────────────────┐│
│  │                    Linux Kernel                     ││
│  │                    共享内核                         ││
│  └─────────────────────────────────────────────────────┘│
│                             │                           │
│  ┌─────────────────────────────────────────────────────┐│
│  │                      Hardware                       ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘

特点：
- 所有容器共享宿主机内核
- 没有 Hypervisor 开销
- 启动时间：秒级
- 内存：MB 级别
- 隔离：进程级别
```
<!-- /DIAGRAM -->

### 关键对比

| 特性 | 虚拟机 | 容器 |
|------|--------|------|
| **内核** | 独立（每个 VM 一个） | 共享（宿主机内核） |
| **启动时间** | 分钟级 | 秒级 |
| **资源开销** | GB 级内存 | MB 级内存 |
| **隔离强度** | 强（硬件级） | 较弱（进程级） |
| **安全边界** | 内核漏洞只影响单个 VM | 内核漏洞影响所有容器 |
| **OS 类型** | 任意（Linux/Windows） | 必须与宿主机内核兼容 |

### 心智模型

记住这个核心公式：

```
Container = Process + Constraints（约束）
```

约束由什么构成？

| 约束类型 | 作用 | 对应技术 |
|----------|------|----------|
| **可见性约束** | 进程能「看到」什么 | Namespace |
| **资源约束** | 进程能「用」多少 | cgroups |
| **系统调用约束** | 进程能「做」什么 | seccomp |
| **权限约束** | 进程有什么「能力」 | capabilities |

本课程将逐一讲解每种约束。

---

## 动手练习

### Lab 1：隔离差异演示

验证容器进程在宿主机上可见。

**步骤 1**：启动一个长时间运行的隔离进程

```bash
# 终端 1：创建隔离的 PID + Network Namespace
sudo unshare --pid --net --fork --mount-proc sleep 3600 &
ISOLATED_PID=$!
echo "Isolated process PID on host: $ISOLATED_PID"
```

**步骤 2**：在宿主机上查看这个进程

```bash
# 终端 2（或同一终端）
ps aux | grep "sleep 3600" | grep -v grep
```

输出类似：

```
root      12345  0.0  0.0   5476   580 pts/0    S    10:30   0:00 sleep 3600
```

**关键发现**：这个「容器」进程在宿主机上完全可见！

如果这是虚拟机，宿主机只能看到 VM 进程，看不到 VM 内部的 sleep。

**清理**：

```bash
sudo kill $ISOLATED_PID 2>/dev/null
```

---

### Lab 2：内核共享验证

验证容器和宿主机共享同一个内核。

**步骤 1**：查看宿主机内核版本

```bash
uname -r
```

记下输出，例如：`6.8.0-40-generic`

**步骤 2**：在隔离环境中查看内核版本

```bash
sudo unshare --pid --net --fork --mount-proc bash -c 'uname -r'
```

**关键发现**：输出完全相同！

容器没有独立内核，它使用宿主机的内核。这意味着：

- **优点**：启动快，资源开销小
- **风险**：内核漏洞影响所有容器

---

### Lab 3：Namespace 隔离验证

使用脚本验证不同 Namespace 的隔离效果。

```bash
# 运行隔离演示脚本
cd ~/cloud-atlas/foundations/linux/containers/01-containers-vs-vms/code
./isolation-demo.sh
```

或手动执行：

```bash
# 创建完整隔离环境
sudo unshare --pid --net --uts --mount --fork --mount-proc bash
```

在隔离环境中：

```bash
# 检查主机名
hostname
# 修改主机名（只影响这个隔离环境）
hostname container-demo
hostname  # 已改变

# 检查进程
ps aux  # 只看到隔离环境中的进程

# 检查网络
ip addr  # 只有 lo

# 退出
exit
```

回到宿主机，检查主机名：

```bash
hostname  # 没有改变！
```

---

## 何时用容器，何时用 VM？

### 选择容器

- 微服务架构
- 快速部署、频繁更新
- 无状态应用
- 开发/测试环境
- 需要高密度部署

### 选择虚拟机

- 需要强隔离（多租户、安全敏感）
- 运行不同操作系统（Windows on Linux host）
- 遗留系统迁移
- 需要独立内核版本
- 符合合规要求（某些安全标准）

### 混合方案

生产环境常见模式：**VM 中运行容器**

```
┌───────────────────────────────────────────────────────┐
│                   物理服务器                           │
├───────────────────────────────────────────────────────┤
│  ┌─────────────────────┐  ┌─────────────────────┐     │
│  │       VM 1          │  │       VM 2          │     │
│  │  ┌───┐ ┌───┐ ┌───┐  │  │  ┌───┐ ┌───┐ ┌───┐  │     │
│  │  │C1 │ │C2 │ │C3 │  │  │  │C4 │ │C5 │ │C6 │  │     │
│  │  └───┘ └───┘ └───┘  │  │  └───┘ └───┘ └───┘  │     │
│  │      Kubernetes     │  │     Kubernetes      │     │
│  └─────────────────────┘  └─────────────────────┘     │
│                Hypervisor (KVM)                       │
└───────────────────────────────────────────────────────┘
```

这样既有 VM 的强隔离（不同租户不同 VM），又有容器的灵活部署（同 VM 内多容器）。

---

## 职场小贴士

### 日本 IT 现场常见场景

**场景 1：コンテナ導入提案（容器导入提案）**

```
上司：「なぜ Docker を使うの？VM じゃダメ？」
（为什么用 Docker？VM 不行吗？）

回答のポイント：
- 起動時間：秒単位 vs 分単位
- リソース効率：同じサーバーに多くのアプリを配置可能
- デプロイ頻度：1日数回のリリースに対応可能
- ただし：強い隔離が必要な場合は VM を使う
```

**场景 2：セキュリティ監査対応（安全审计应对）**

```
監査：「コンテナの隔離は十分ですか？」
（容器的隔离足够吗？）

回答のポイント：
- コンテナはプロセスレベルの隔離
- カーネルを共有するため、カーネル脆弱性は影響がある
- 対策：rootless コンテナ、seccomp、capabilities 制限
- 強い隔離が必要なら VM + コンテナの組み合わせ
```

**场景 3：障害対応（故障处理）**

```
アラート：「Pod が突然消えた」

確認ポイント：
1. コンテナログ → docker logs / kubectl logs
2. 宿主機ログ → dmesg | grep -i oom
3. リソース状態 → memory.events

コンテナ = プロセスなので、
宿主機の視点で調査することが重要！
```

---

## 检查清单

完成本课后，你应该能够：

- [ ] 使用 `unshare --net` 创建网络隔离环境
- [ ] 解释容器和虚拟机的核心区别（共享内核 vs 独立内核）
- [ ] 说出「Container = Process + Constraints」心智模型
- [ ] 在宿主机上找到「容器」进程（ps aux）
- [ ] 验证容器和宿主机使用相同内核版本（uname -r）
- [ ] 判断场景适合用容器还是虚拟机

---

## 延伸阅读

### 官方文档

- [Linux Namespaces - man7.org](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [unshare(1) - Linux manual](https://man7.org/linux/man-pages/man1/unshare.1.html)
- [cgroups - Kernel Documentation](https://www.kernel.org/doc/Documentation/cgroup-v2.txt)

### 相关课程

- [Lesson 02 - Namespace 概览](../02-namespace-overview/) - 7 种 Namespace 详解
- [Lesson 05 - cgroups v2 架构](../05-cgroups-v2-architecture/) - 资源控制原理
- [LX06 - 网络基础](../../network/) - Network Namespace 深入

### 推荐阅读

- *Container Security* by Liz Rice - 容器安全权威指南
- OCI Runtime Specification - 容器标准规范

---

## 系列导航

[Home](../) | [02 - Namespace 概览 -->](../02-namespace-overview/)
